          *SVPIC, *LDPIC compressed screen saving and loading          ===================================================                          v2.10 - 23-Dec-2017*LDPIC and *SVPIC are commands to load and save compressed screen images,including the palette information. They work on BBC and Master and withshadow screens on the Master, Aries-B32 and Watford shadow screen systems.The original code for them was published in the October 1986 issue ofAcorn User, issue number 51. The original code was broken and failed onmany systems, and was rewritten as v2.00 by J.G.Harston. The latestversion has been extended to transparently support 12-bit palettes. An oldversion of LDPIC will load a new version LDPIC file and will ignore anyextensions. A new version of LDPIC will load an old version LDPIC filewithout any extensions.*LDPIC <afsp>-------------Loads in a compressed screen picture saved with *SVPIC with its paletteinformation. If a shadow screen mode is selected, then any mode changewill also be a shadow mode. On a B+ non-shadow modes are forced. Shadowscreen is no supported on the B+ as the hardware only allows the VDUdriver code between &C000 and &DFFF to access the shadow screen memory.*SVPIC <fsp>------------Saves a screen picture, and attempts to compress it. Makes several passesthrough the data to find the smallest possible output file, so can take upto about 2 minutes to complete. It is theoretically possible for a verycomplex picture to result in a file larger than a simple *SAVE wouldcreate.Technical details-----------------The file data is a bit stream that is read from bit 7 of each byte in thefile into bit 7 of the receiving data byte, so data bytes in the file arereversed compared to their value.The file contains several blocks, each of which starts aligned to a byteboundary:Offset Size     Name    Description------------------------------------------------------------------------- 0000  1 byte   DATAW   Data width - number of bits in DATA entries. 0001  1 byte   MODE    Screen mode. 0002  8 bytes  PALETTE Palette entries, 16 values of 4-bit FBGR colours.                        Colour 15 is first, colour 0 is last. 000A  1 byte   STEP    Step-1 between bytes loaded to the image memory. 000B  1 byte   COUNTW  Count width - number of bits in COUNT entries. 000C    ...    DATA    Image Data xxxx 24 bytes  PAL12   Optional 12-bit palette data, 16 sets of three                        4-bit {red, green, blue} colour values. Colour 15                        is first, colour 0 is last. yyyy  1 byte   len         ...    NAUX    If len>0: optional nULA control data{ repeat: zzzz  1 byte   len         ...    extra   If len>0: extra information blocks}If the 12-bit palette data is present it can be followed by any number ofblocks of "len, { len x byte }" sequences. The first of these sequences iscontrol data to write to the nULA auxilary control data. For example, thesequence {1, &11} programs the nULA to use logical colour mapping.The palette entries at PALETTE map logical colour numbers to physicalcolour numbers. By default, the palette entries at PAL12 then map thosephysical colour numbers to 12-bit analogue colour values. So, if colour 2is mapped to physical colour 4 (blue) in PALETTE, entry 4 in PAL12 mapsthat to a 12-bit colour value.If the NAUX control data includes the &11 control byte, that switches tousing logical colour mapping. Then, the logical colour numbers are mappeddirectly to 12-bit analogue colour values in PAL12 ignoring the colournumbers in PALETTE. In the above example, colour 2 is mapped to theanalogue colour value in entry 2 in PAL12.In all cases, PALETTE must contain a set of 4-bit physical colour numbersso the image is viewable on systems with only 4-bit colour hardware.The file can terminate at any point and the load must terminate cleanly atthat point. For instance, a file could contain just the data for the tophalf of the screen, and omit the bottom half of the screen. If the fileterminates early there cannot be any subsequent blocks.Each block (header, image data, palette, extensions) is byte aligned, soother than the compressed image data they can be simply read as bytevalues and the bits reversed.The file contents are optimised to be read efficiently. An inefficiency isthat to read and update the PAL12 and subsequent entries, the whole filehas to be scanned through to find where the end of the image data is.As a bit stream the file contents looks like the following, with bit 7 ofeach file byte being the first read and becoming bit 0 of the resultingvalue.Header bit stream~~~~~~~~~~~~~~~~~+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|w w w w 0 0 0 0|m m m 0 0 0 0 m|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     DATAW            MODE+-+-+-+-+-+-+-+-+-+-+-+-+-+...+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|r g b f|r g b f|r g b f|r ... f|r g b f|r g b f|r g b f|r g b f|r g b f|+-+-+-+-+-+-+-+-+-+-+-+-+-+...+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   15      14      13               4       3       2       1       0                         palette entries+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|s s s s 0 0 0 0|c c c c 0 0 0 0|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     STEP            COUNTWData bit stream~~~~~~~~~~~~~~~                   +-+-....-+      +-+-...-+-....-+Multiple sets of:  |0| DATA |  or  |1|COUNT| DATA |  until end of screen or                   +-+-....-+      +-+-...-+-....-+  end of file12-bit palette bit stream~~~~~~~~~~~~~~~~~~~~~~~~~+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...|r r r r|g g g g|b b b b|r r r r|g g g g|b b b b|r g b f|....+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...  \--------15--------/    \--------14--------/    ...+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   ....|b b b b|r r r r|g g g g|b b b b|r r r r|g g g g|b b b b|    ...+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                  \---------1--------/    \---------0--------/Extended palette control block bit stream~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+-+-+-+-+-+-+-+-+            +-+-+-+-+-+-+-+-+|n n n n n n n n|  n sets of |d d d d d d d d|+-+-+-+-+-+-+-+-+            +-+-+-+-+-+-+-+-+The data bytes are written to the nULA auxilary control register. Thisallows logical colour mapping, border colours, and non-standard geometriesto be included in the file. Remember, the bit stream is reversed comparedto the actual byte values. See nULA documentation for more details.Typical values would be:    &0n - select 3-bit RGB border colour    &11 - use logical 12-bit palette mappingDecompression code------------------The following BASIC code shows how to decompress the image data.  bits%=0:dw%=FNget(8):mode%=FNget(8)  FOR colour%=15 TO 0 STEP -1    palette%?colour%=FNget(4)  NEXT colour%  stp%=FNget(8):cw%=FNget(8)  fsize%=256*EVAL("&"+MID$("5050504028282004",(mode%AND7)*2+1,2))  off%=stp%-1:addr%=mem%+off%  REPEAT    cnt%=1:IF FNbit:cnt%=FNget(cw%)    byt%=FNget(dw%)    FOR A%=1 TO cnt%      ?addr%=byt%:addr%=addr%+stp%      IF addr%>=mem%+fsize%:off%=off%-1:addr%=mem%+off%    NEXT A%  UNTIL off%<0 OR EOF#in%:bits%=0  IF addr%>mem%:fsize%=addr%-mem%The following BASIC code can be used to read the bitstream from an openfile with the handle in in%:  DEFFNbit:IFbits%=0:byte%=BGET#in%:bits%=8  byte%=byte%*2:bits%=bits%-1:=byte%AND256  DEFFNget(N%):LOCALA%,B%:FORB%=1TON%:A%=(A%DIV2)ORFNbit:NEXT  REPEATA%=A%DIV2:N%=N%+1:UNTILN%>8:=A%Example data------------           0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F   000000 10  80  0C  82  0C  82  0C  82  0C  82  80  E0  FF  AA  FF  AA           |   |   |   |   |   |   |   |   |   |   |   |  |       |DATAW=8  --+   |   |   |   |   |   |   |   |   |   |   |  +-----------1,COUNT=127,DATA=&55MODE 1   ------+   |   |   |   |   |   |   |   |   |   |          |Palette  ---------0 3 1 4 0 3 1 4 0 3 1 4 0 3 1 4  |   |          +---1,COUNT=127,DATA=&55STEP=1   ------------------------------------------+   |COUNTW=7 ----------------------------------------------+	 *ScrSave, *ScrLoad compressed screen saving and loading	 =======================================================		    J.G.Harston - v1.08 - 15-Dec-1992*ScrLoad and *ScrSave are commands to load and save compressed screenimages, including the palette information. They work on BBC and Master andwith shadow screens on the Master, Aries-B32 and Watford shadow screensystems.*ScrLoad <afsp>---------------Loads in a compressed screen picture saved with *ScrSave with its paletteinformation. If a shadow screen mode is selected, then any mode changewill also be a shadow mode. On a B+ non-shadow modes are forced. Shadowscreen cannot be supported on the B+ as the hardware only allows the VDUdriver code between &C000 and &DFFF to access the shadow screen memory.*ScrSave <fsp>--------------Saves a screen picture, and attempts to compress it. If compressing itwould make a longer file (as a very detailed picture would), then thepicture is saved without compressing it.Technical details-----------------The palette information, screen mode and compression information is savedin the load and execution addresses of the file.Load address:      &FFFFabbbb    a:   currently unused and ignored    bbb: colours 4 to 7 held as %777666555444 in sixteen colour modeExecution address: &iiipmcccc    iii:  000 for compressed, FFF for uncompressed    p:    if compressed: number of passes 0=1, 1=2, 2=8, otherwise F    m:    screen mode    ccc:  colours 0 to 3 held as %333222111000For example, the file:    JARRE   FFFF3000 FFFF10CC 5000is uncompressed, screen mode 1, palette entries 4, 1, 3, 0.The file:    PYRAMID FFFF0FAC 00002248 0A94is compressed, one pass, screen mode 2, palette entries 0, 1, 1, 1, 4, 5,6, 7.With a sixteen-colour screen mode, the first four bytes of the file arereplaced with palette colours 8 to 15. On loading with *ScrLoad, thesefour bytes are set to the same as the following four bytes.Compressed file contents are run-length encoded. The file is a series ofpairs of bytes, each pair being {run},{value}. A run of &00 means a run of256 bytes.